name: Size Report

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: size-report-${{ github.ref }}
  cancel-in-progress: true

env:
  LLVM_VERSION: "21.1.0"

jobs:
  build-windows:
    runs-on: windows-2022
    strategy:
      fail-fast: false
      matrix:
        arch: [i386, x86_64, aarch64]
        exclude:
          - arch: aarch64
    outputs:
      sizes: ${{ steps.sizes.outputs.result }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache LLVM
        id: cache-llvm
        uses: actions/cache@v4
        with:
          path: C:\Program Files\LLVM
          key: llvm-${{ env.LLVM_VERSION }}-windows-2022

      - name: Install Ninja
        shell: pwsh
        run: choco install ninja -y

      - name: Install LLVM
        if: steps.cache-llvm.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $ver = "${{ env.LLVM_VERSION }}"
          $exe = "LLVM-$ver-win64.exe"
          $url = "https://github.com/llvm/llvm-project/releases/download/llvmorg-$ver/$exe"
          Invoke-WebRequest -Uri $url -OutFile $exe
          Start-Process -FilePath ".\$exe" -ArgumentList "/S" -Wait

      - name: Add LLVM to PATH
        shell: pwsh
        run: '"C:\Program Files\LLVM\bin" | Out-File -FilePath $env:GITHUB_PATH -Append'

      - name: Build with -Oz (no logging)
        shell: pwsh
        run: |
          cmake --preset windows-${{ matrix.arch }}-release -DOPTIMIZATION_LEVEL=Oz -DENABLE_LOGGING=OFF
          cmake --build --preset windows-${{ matrix.arch }}-release

      - name: Get sizes
        id: sizes
        shell: pwsh
        run: |
          $exe = Get-ChildItem -Path build -Recurse -Filter "output.exe" | Select-Object -First 1
          $bin = Get-ChildItem -Path build -Recurse -Filter "output.bin" | Select-Object -First 1
          $exeSize = if ($exe) { $exe.Length } else { 0 }
          $binSize = if ($bin) { $bin.Length } else { 0 }
          $result = "windows-${{ matrix.arch }},$exeSize,$binSize"
          echo "result=$result" >> $env:GITHUB_OUTPUT

      - name: Upload size data
        uses: actions/upload-artifact@v4
        with:
          name: size-windows-${{ matrix.arch }}
          retention-days: 1
          path: |
            build/**/output.exe
            build/**/output.bin

  build-windows-aarch64:
    runs-on: windows-11-arm
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache LLVM
        id: cache-llvm
        uses: actions/cache@v4
        with:
          path: C:\Program Files\LLVM
          key: llvm-${{ env.LLVM_VERSION }}-windows-11-arm

      - name: Install Ninja
        shell: pwsh
        run: choco install ninja -y

      - name: Install LLVM
        if: steps.cache-llvm.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $ver = "${{ env.LLVM_VERSION }}"
          $exe = "LLVM-$ver-win64.exe"
          $url = "https://github.com/llvm/llvm-project/releases/download/llvmorg-$ver/$exe"
          Invoke-WebRequest -Uri $url -OutFile $exe
          Start-Process -FilePath ".\$exe" -ArgumentList "/S" -Wait

      - name: Add LLVM to PATH
        shell: pwsh
        run: '"C:\Program Files\LLVM\bin" | Out-File -FilePath $env:GITHUB_PATH -Append'

      - name: Build with -Oz
        shell: pwsh
        run: |
          cmake --preset windows-aarch64-release -DOPTIMIZATION_LEVEL=Oz -DENABLE_LOGGING=OFF
          cmake --build --preset windows-aarch64-release

      - name: Get sizes
        id: sizes
        shell: pwsh
        run: |
          $exe = Get-ChildItem -Path build -Recurse -Filter "output.exe" | Select-Object -First 1
          $bin = Get-ChildItem -Path build -Recurse -Filter "output.bin" | Select-Object -First 1
          $exeSize = if ($exe) { $exe.Length } else { 0 }
          $binSize = if ($bin) { $bin.Length } else { 0 }
          $result = "windows-aarch64,$exeSize,$binSize"
          echo "result=$result" >> $env:GITHUB_OUTPUT

      - name: Upload size data
        uses: actions/upload-artifact@v4
        with:
          name: size-windows-aarch64
          retention-days: 1
          path: |
            build/**/output.exe
            build/**/output.bin

  build-linux:
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        arch: [i386, x86_64, armv7a, aarch64]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache LLVM
        id: cache-llvm
        uses: actions/cache@v4
        with:
          path: /opt/llvm
          key: llvm-${{ env.LLVM_VERSION }}-linux-x64

      - name: Install LLVM
        if: steps.cache-llvm.outputs.cache-hit != 'true'
        run: |
          set -e
          TARBALL="LLVM-${{ env.LLVM_VERSION }}-Linux-X64.tar.xz"
          URL="https://github.com/llvm/llvm-project/releases/download/llvmorg-${{ env.LLVM_VERSION }}/${TARBALL}"
          wget -q "$URL"
          sudo mkdir -p /opt/llvm
          sudo tar xf "$TARBALL" -C /opt/llvm --strip-components=1
          rm "$TARBALL"

      - name: Install build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y ninja-build cmake

      - name: Add LLVM to PATH
        run: echo "/opt/llvm/bin" >> $GITHUB_PATH

      - name: Build with -Oz
        run: |
          cmake --preset linux-${{ matrix.arch }}-release -DOPTIMIZATION_LEVEL=Oz -DENABLE_LOGGING=OFF
          cmake --build --preset linux-${{ matrix.arch }}-release

      - name: Get sizes
        id: sizes
        run: |
          ELF=$(find build -type f -name "output.elf" | head -n 1)
          BIN=$(find build -type f -name "output.bin" | head -n 1)
          ELF_SIZE=$(stat -c%s "$ELF" 2>/dev/null || echo 0)
          BIN_SIZE=$(stat -c%s "$BIN" 2>/dev/null || echo 0)
          echo "result=linux-${{ matrix.arch }},$ELF_SIZE,$BIN_SIZE" >> $GITHUB_OUTPUT

      - name: Upload size data
        uses: actions/upload-artifact@v4
        with:
          name: size-linux-${{ matrix.arch }}
          retention-days: 1
          path: |
            build/**/output.elf
            build/**/output.bin

  build-macos:
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x86_64
            runner: macos-13
            llvm_tarball: "LLVM-21.1.0-macOS-X64.tar.xz"
          - arch: aarch64
            runner: macos-14
            llvm_tarball: "LLVM-21.1.0-macOS-ARM64.tar.xz"
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache LLVM
        id: cache-llvm
        uses: actions/cache@v4
        with:
          path: /opt/llvm
          key: llvm-${{ env.LLVM_VERSION }}-macos-${{ matrix.arch }}

      - name: Install LLVM
        if: steps.cache-llvm.outputs.cache-hit != 'true'
        run: |
          set -e
          URL="https://github.com/llvm/llvm-project/releases/download/llvmorg-${{ env.LLVM_VERSION }}/${{ matrix.llvm_tarball }}"
          wget -q "$URL"
          sudo mkdir -p /opt/llvm
          sudo tar xf "${{ matrix.llvm_tarball }}" -C /opt/llvm --strip-components=1
          rm "${{ matrix.llvm_tarball }}"

      - name: Install build tools
        run: brew install ninja cmake

      - name: Add LLVM to PATH
        run: echo "/opt/llvm/bin" >> $GITHUB_PATH

      - name: Build with -Oz
        run: |
          cmake --preset macos-${{ matrix.arch }}-release -DOPTIMIZATION_LEVEL=Oz -DENABLE_LOGGING=OFF
          cmake --build --preset macos-${{ matrix.arch }}-release

      - name: Get sizes
        id: sizes
        run: |
          MACHO=$(find build -type f -name "output" ! -name "*.bin" ! -name "*.txt" | head -n 1)
          BIN=$(find build -type f -name "output.bin" | head -n 1)
          MACHO_SIZE=$(stat -f%z "$MACHO" 2>/dev/null || echo 0)
          BIN_SIZE=$(stat -f%z "$BIN" 2>/dev/null || echo 0)
          echo "result=macos-${{ matrix.arch }},$MACHO_SIZE,$BIN_SIZE" >> $GITHUB_OUTPUT

      - name: Upload size data
        uses: actions/upload-artifact@v4
        with:
          name: size-macos-${{ matrix.arch }}
          retention-days: 1
          path: |
            build/**/output
            build/**/output.bin

  build-uefi:
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        arch: [x86_64, aarch64]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache LLVM
        id: cache-llvm
        uses: actions/cache@v4
        with:
          path: /opt/llvm
          key: llvm-${{ env.LLVM_VERSION }}-linux-x64

      - name: Install LLVM
        if: steps.cache-llvm.outputs.cache-hit != 'true'
        run: |
          set -e
          TARBALL="LLVM-${{ env.LLVM_VERSION }}-Linux-X64.tar.xz"
          URL="https://github.com/llvm/llvm-project/releases/download/llvmorg-${{ env.LLVM_VERSION }}/${TARBALL}"
          wget -q "$URL"
          sudo mkdir -p /opt/llvm
          sudo tar xf "$TARBALL" -C /opt/llvm --strip-components=1
          rm "$TARBALL"

      - name: Install build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y ninja-build cmake

      - name: Add LLVM to PATH
        run: echo "/opt/llvm/bin" >> $GITHUB_PATH

      - name: Build with -Oz
        run: |
          cmake --preset uefi-${{ matrix.arch }}-release -DOPTIMIZATION_LEVEL=Oz -DENABLE_LOGGING=OFF
          cmake --build --preset uefi-${{ matrix.arch }}-release

      - name: Get sizes
        id: sizes
        run: |
          EFI=$(find build -type f -name "output.efi" | head -n 1)
          BIN=$(find build -type f -name "output.bin" | head -n 1)
          EFI_SIZE=$(stat -c%s "$EFI" 2>/dev/null || echo 0)
          BIN_SIZE=$(stat -c%s "$BIN" 2>/dev/null || echo 0)
          echo "result=uefi-${{ matrix.arch }},$EFI_SIZE,$BIN_SIZE" >> $GITHUB_OUTPUT

      - name: Upload size data
        uses: actions/upload-artifact@v4
        with:
          name: size-uefi-${{ matrix.arch }}
          retention-days: 1
          path: |
            build/**/output.efi
            build/**/output.bin

  update-readme:
    needs: [build-windows, build-windows-aarch64, build-linux, build-macos, build-uefi]
    runs-on: ubuntu-22.04
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all size artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Collect sizes
        env:
          COMMIT_SHA: ${{ github.sha }}
        run: |
          python3 << 'EOF'
          import json
          import os
          from pathlib import Path
          from datetime import datetime

          def format_size(size):
              if size is None or size == 0:
                  return "-"
              elif size < 1024:
                  return f"{size} B"
              else:
                  return f"{size / 1024:.1f} KB"

          # Collect current sizes
          sizes_formatted = {}
          sizes_raw = {}
          artifacts_dir = Path("artifacts")

          for size_dir in artifacts_dir.glob("size-*"):
              platform_arch = size_dir.name.replace("size-", "")
              exe_file = None
              for ext in ["output.exe", "output.elf", "output.efi"]:
                  files = list(size_dir.rglob(ext))
                  if files:
                      exe_file = files[0]
                      break
              # macOS Mach-O has no extension - look for "output" without extension
              if exe_file is None and "macos" in platform_arch:
                  for f in size_dir.rglob("output"):
                      if f.is_file() and f.suffix == "" and f.stat().st_size > 0:
                          exe_file = f
                          break
              bin_files = list(size_dir.rglob("output.bin"))
              bin_file = bin_files[0] if bin_files else None

              exe_size = exe_file.stat().st_size if exe_file else None
              bin_size = bin_file.stat().st_size if bin_file else None

              key = platform_arch.replace("-", "_")
              sizes_formatted[f"{key}_exe"] = format_size(exe_size)
              sizes_formatted[f"{key}_bin"] = format_size(bin_size)
              if bin_size:
                  sizes_raw[f"{key}_bin"] = bin_size

          # Save formatted sizes for badges
          Path("sizes.json").write_text(json.dumps(sizes_formatted, indent=2))

          # Save this commit's data as individual file
          date_str = datetime.utcnow().strftime("%Y-%m-%d")
          commit_short = os.environ["COMMIT_SHA"][:7]
          commit_data = {
              "date": date_str,
              "commit": commit_short,
              "sizes": sizes_raw
          }

          Path("sizes").mkdir(exist_ok=True)
          filename = f"sizes/{date_str}_{commit_short}.json"
          Path(filename).write_text(json.dumps(commit_data, indent=2))

          print(f"Saved: {filename}")
          print(json.dumps(sizes_formatted, indent=2))
          EOF

      - name: Fetch existing history and generate chart
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin build-sizes 2>/dev/null || true

          # Copy existing size files from build-sizes branch
          if git rev-parse --verify origin/build-sizes >/dev/null 2>&1; then
            git archive origin/build-sizes -- sizes/ 2>/dev/null | tar -x 2>/dev/null || true
          fi

          python3 << 'EOF'
          import json
          from pathlib import Path

          # Load all size entries from individual files
          sizes_dir = Path("sizes")
          entries = []

          for f in sorted(sizes_dir.glob("*.json")):
              try:
                  data = json.loads(f.read_text())
                  entries.append(data)
              except:
                  pass

          # Keep last 50 entries
          entries = entries[-50:]

          # Remove old files if we have more than 50
          all_files = sorted(sizes_dir.glob("*.json"))
          if len(all_files) > 50:
              for f in all_files[:-50]:
                  f.unlink()

          print(f"Found {len(entries)} data points")

          # Generate SVG chart
          if len(entries) < 2:
              Path("size_chart.svg").write_text('''<svg xmlns="http://www.w3.org/2000/svg" width="800" height="400">
                <rect width="800" height="400" fill="#0d1117"/>
                <text x="400" y="200" fill="#8b949e" text-anchor="middle" font-family="monospace">Collecting data... (need 2+ builds)</text>
              </svg>''')
          else:
              width, height = 800, 400
              margin = {"top": 40, "right": 150, "bottom": 60, "left": 70}
              chart_w = width - margin["left"] - margin["right"]
              chart_h = height - margin["top"] - margin["bottom"]

              platforms = [
                  ("windows_i386_bin", "#58a6ff", "Win i386"),
                  ("windows_x86_64_bin", "#1f6feb", "Win x64"),
                  ("windows_aarch64_bin", "#388bfd", "Win ARM64"),
                  ("linux_i386_bin", "#3fb950", "Linux i386"),
                  ("linux_x86_64_bin", "#238636", "Linux x64"),
                  ("linux_armv7a_bin", "#2ea043", "Linux ARM"),
                  ("linux_aarch64_bin", "#56d364", "Linux ARM64"),
                  ("macos_x86_64_bin", "#bc8cff", "macOS x64"),
                  ("macos_aarch64_bin", "#d2a8ff", "macOS ARM64"),
                  ("uefi_x86_64_bin", "#f78166", "UEFI x64"),
                  ("uefi_aarch64_bin", "#ffa657", "UEFI ARM64"),
              ]

              all_sizes = []
              for e in entries:
                  for key, _, _ in platforms:
                      if key in e["sizes"]:
                          all_sizes.append(e["sizes"][key])

              if not all_sizes:
                  min_size, max_size = 0, 1
              else:
                  min_size = min(all_sizes) * 0.9
                  max_size = max(all_sizes) * 1.1

              def scale_x(i):
                  return margin["left"] + (i / (len(entries) - 1)) * chart_w if len(entries) > 1 else margin["left"]

              def scale_y(val):
                  if max_size == min_size:
                      return margin["top"] + chart_h / 2
                  return margin["top"] + chart_h - ((val - min_size) / (max_size - min_size)) * chart_h

              svg_parts = [
                  f'<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}">',
                  '<defs>',
                  '<style>',
                  '.axis-text { fill: #8b949e; font-family: monospace; font-size: 11px; }',
                  '.title { fill: #c9d1d9; font-family: monospace; font-size: 14px; font-weight: bold; }',
                  '.legend { fill: #8b949e; font-family: monospace; font-size: 10px; }',
                  '.grid { stroke: #21262d; stroke-width: 1; }',
                  '</style>',
                  '</defs>',
                  f'<rect width="{width}" height="{height}" fill="#0d1117"/>',
                  f'<text x="{width/2}" y="25" class="title" text-anchor="middle">Binary Size Trend (.bin)</text>',
              ]

              num_ticks = 5
              for i in range(num_ticks + 1):
                  y = margin["top"] + (i / num_ticks) * chart_h
                  val = max_size - (i / num_ticks) * (max_size - min_size)
                  svg_parts.append(f'<line x1="{margin["left"]}" y1="{y}" x2="{margin["left"] + chart_w}" y2="{y}" class="grid"/>')
                  svg_parts.append(f'<text x="{margin["left"] - 10}" y="{y + 4}" class="axis-text" text-anchor="end">{val/1024:.0f}KB</text>')

              step = max(1, len(entries) // 6)
              for i in range(0, len(entries), step):
                  x = scale_x(i)
                  svg_parts.append(f'<text x="{x}" y="{height - margin["bottom"] + 20}" class="axis-text" text-anchor="middle">{entries[i]["date"][5:]}</text>')

              # Collect all label positions first for collision detection
              all_labels = []  # [(x, y, text, color), ...]

              for key, color, label in platforms:
                  points = []
                  sizes_at_points = []
                  for i, e in enumerate(entries):
                      if key in e["sizes"]:
                          points.append((scale_x(i), scale_y(e["sizes"][key])))
                          sizes_at_points.append(e["sizes"][key])

                  if len(points) >= 2:
                      path_d = f'M {points[0][0]:.1f} {points[0][1]:.1f}'
                      for x, y in points[1:]:
                          path_d += f' L {x:.1f} {y:.1f}'
                      svg_parts.append(f'<path d="{path_d}" fill="none" stroke="{color}" stroke-width="2" opacity="0.8"/>')

                      # Add circles at regular intervals (exclude last point, handled separately)
                      label_step = max(1, len(points) // 5)  # Show ~5 labels per line
                      last_idx = len(points) - 1
                      for idx in range(0, len(points), label_step):
                          if idx == last_idx:
                              continue  # Skip last point here, add it below with larger circle
                          px, py = points[idx]
                          size_val = sizes_at_points[idx]
                          size_label = f"{size_val/1024:.1f}KB"
                          svg_parts.append(f'<circle cx="{px:.1f}" cy="{py:.1f}" r="3" fill="{color}"/>')
                          all_labels.append((px, py - 8, size_label, color))

                      # Always show the last point with larger circle
                      last_x, last_y = points[-1]
                      last_size = sizes_at_points[-1]
                      size_label = f"{last_size/1024:.1f}KB"
                      svg_parts.append(f'<circle cx="{last_x:.1f}" cy="{last_y:.1f}" r="4" fill="{color}"/>')
                      all_labels.append((last_x, last_y - 8, size_label, color))

              # Sort labels by x position, then y position for consistent ordering
              all_labels.sort(key=lambda l: (l[0], l[1]))

              # Resolve label collisions with iterative adjustment
              min_label_spacing = 18  # Minimum vertical spacing between labels
              label_width = 45        # Approximate width of label text
              placed_labels = []      # [(x, y, text, color), ...]

              for lx, ly, text, color in all_labels:
                  final_y = ly
                  # Iteratively resolve collisions (max 20 iterations to prevent infinite loops)
                  for _ in range(20):
                      collision = False
                      for px, py, _, _ in placed_labels:
                          # Check if labels overlap (similar x position and y too close)
                          if abs(lx - px) < label_width and abs(final_y - py) < min_label_spacing:
                              collision = True
                              # Move label away from collision
                              if final_y >= py:
                                  final_y = py + min_label_spacing
                              else:
                                  final_y = py - min_label_spacing
                      if not collision:
                          break
                  placed_labels.append((lx, final_y, text, color))
                  svg_parts.append(f'<text x="{lx:.1f}" y="{final_y:.1f}" fill="{color}" font-family="monospace" font-size="8px" text-anchor="middle">{text}</text>')

              legend_x = width - margin["right"] + 15
              for i, (key, color, label) in enumerate(platforms):
                  y = margin["top"] + 10 + i * 18
                  svg_parts.append(f'<rect x="{legend_x}" y="{y - 6}" width="12" height="12" fill="{color}"/>')
                  svg_parts.append(f'<text x="{legend_x + 18}" y="{y + 4}" class="legend">{label}</text>')

              svg_parts.append('</svg>')
              Path("size_chart.svg").write_text('\n'.join(svg_parts))

          print(f"Generated chart with {len(entries)} data points")
          EOF

      - name: Deploy to build-sizes branch
        run: |
          # Save files before branch switch
          cp sizes.json /tmp/sizes.json
          cp size_chart.svg /tmp/size_chart.svg
          cp -r sizes /tmp/sizes

          # Remove files to avoid checkout conflict
          rm -rf sizes sizes.json size_chart.svg

          # Checkout build-sizes branch, or create orphan if it doesn't exist
          git branch -D build-sizes 2>/dev/null || true
          if git rev-parse --verify origin/build-sizes >/dev/null 2>&1; then
            git checkout -b build-sizes origin/build-sizes
          else
            git checkout --orphan build-sizes
            git rm -rf . 2>/dev/null || true
          fi

          # Restore files
          mv /tmp/sizes.json sizes.json
          mv /tmp/size_chart.svg size_chart.svg
          rm -rf sizes
          mv /tmp/sizes sizes

          # Commit and push
          git add sizes.json size_chart.svg sizes/
          git diff --staged --quiet || git commit -m "Update binary sizes [$(date -u +%Y-%m-%d)]"
          git push origin build-sizes --force
